<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ì•„ìŠ¤íŠ¸ë¼ ì›Œì¦ˆ â€” ì²´ê³„í™”íŒ</title>
<style>
  :root{
    --cell:56px;--gap:6px;--bg:#f3f6f8;--accent:#0b5cff;
    --dark:#e6eef9;--light:#ffffff;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:#111;display:flex;flex-direction:column;align-items:center;min-height:100vh;padding:18px}
  h1{margin:6px 0 12px}
  .wrap{display:flex;gap:20px;align-items:flex-start;width:100%;max-width:1200px}
  .board-wrap{flex:0 0 auto;display:flex;align-items:center;justify-content:center;padding:20px}
  #board{display:grid;grid-template-columns:repeat(10,var(--cell));grid-auto-rows:var(--cell);gap:var(--gap);background:#222;padding:10px;border-radius:10px}
  .cell{position:relative;border-radius:8px;display:flex;align-items:flex-start;justify-content:flex-start;padding:6px;cursor:pointer;user-select:none;overflow:hidden}
  .cell.light{background:var(--light)}
  .cell.dark{background:var(--dark)}
  .coord{position:absolute;left:6px;top:6px;font-size:11px;color:#666;pointer-events:none}
  .piece{width:42px;height:42px;border-radius:50%;box-shadow:inset 0 -4px rgba(0,0,0,0.12);display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:700}
  .p0{background:#111;color:#fff}
  .p1{background:#fff;color:#111;border:1px solid #ddd}
  .type-label{position:absolute;right:6px;bottom:6px;font-size:10px;color:#333;pointer-events:none}
  .core1{background:linear-gradient(180deg,#fff2f2,#ffecec);border:2px solid #ff7b7b}
  .core2{background:linear-gradient(180deg,#f2f8ff,#e6f2ff);border:2px solid #7bb7ff}
  .core-border{box-shadow:0 0 0 4px rgba(11,92,255,0.06) inset}
  .highlight-move{outline:3px solid rgba(34,197,94,.92);outline-offset:-3px}
  .highlight-attack{outline:3px solid rgba(220,38,38,.92);outline-offset:-3px}
  .stasis-overlay{position:absolute;inset:0;background:rgba(0,0,0,0.12);display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;font-size:18px}
  .sidebar{flex:1 1 360px;max-width:420px}
  .panel{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 20px rgba(10,20,40,0.06)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#fff;font-weight:700;cursor:pointer}
  .btn[disabled]{opacity:.5;cursor:default}
  .log{margin-top:10px;height:240px;overflow:auto;padding:8px;border-radius:8px;border:1px solid #eef2ff;background:#fbfdff;font-size:13px}
  .stat{margin-top:8px}
  .core-hp{display:inline-block;padding:6px 8px;border-radius:8px;background:#fff;border:1px solid #eee}
  ul{margin:6px 0 0 18px;padding:0}
  small{color:#666}
  @media(max-width:900px){
    .wrap{flex-direction:column;align-items:center}
    .board-wrap{order:1}
    .sidebar{order:2;width:100%;max-width:unset}
  }
</style>
</head>
<body>
  <h1>ì•„ìŠ¤íŠ¸ë¼ ì›Œì¦ˆ â€” ì²´ê³„í™”íŒ</h1>
  <div class="wrap">
    <div class="board-wrap">
      <div id="board" aria-label="game-board"></div>
    </div>

    <div class="sidebar">
      <div class="panel">
        <div class="row"><strong id="turnLabel">í„´: í”Œë ˆì´ì–´ 1 (ê²€ì •)</strong></div>
        <div class="row stat">
          <div>ì„ íƒ: <span id="selLabel">ì—†ìŒ</span></div>
          <div style="margin-left:auto">í„´ìˆ˜: <span id="turnCount">0</span></div>
        </div>

        <div style="margin-top:10px">
          <button id="btnEnd" class="btn">í„´ ì¢…ë£Œ</button>
          <button id="btnReset" class="btn">ë¦¬ì…‹ (R)</button>
        </div>

        <div class="stat" style="margin-top:12px">
          <div>ì½”ì–´ HP</div>
          <div style="display:flex;gap:8px;margin-top:6px">
            <div class="core-hp">í”Œë ˆì´ì–´1: <span id="hpP0">3</span></div>
            <div class="core-hp">í”Œë ˆì´ì–´2: <span id="hpP1">3</span></div>
          </div>
        </div>

        <div style="margin-top:12px"><small>ê¸°ë¬¼ ì„¤ëª…:</small>
          <ul>
            <li><b>Sentinel</b> â€” ì§ì„ (ìƒí•˜ì¢Œìš°)ìœ¼ë¡œ ì´ë™. ì ì„ ë°€ì–´ë‚´ê¸°(push).</li>
            <li><b>Phantom</b> â€” Lì ì í”„(2,1). ì í”„ í›„ 1í„´ ì¿¨ë‹¤ìš´(ë‹¤ìŒ í„´ì€ ì§ì„  1ì¹¸ë§Œ ê°€ëŠ¥).</li>
            <li><b>Arbiter</b> â€” ëŒ€ê°ì„  ë©€ë¦¬ ì´ë™. ì¡ì€ ì§€ì ì— 'ì†ë°•'ì„ ìƒì„±(1í„´ ë™ì•ˆ ì…€ ì‚¬ìš© ì œí•œ).</li>
            <li><b>Crusader</b> â€” ì§ì„  ìµœëŒ€2ì¹¸, ëŒ€ê°ì„  1ì¹¸. ê³µê²© ì‹œ ì ì„ 1ì¹¸ ë°€ê¸°(ë’¤ì¹¸ ë¹„ì–´ì•¼ í•¨).</li>
            <li><b>Drone</b> â€” ì „ì§„(í”Œë ˆì´ì–´ ë°©í–¥). ì½”ì–´ ì§„ì… ì‹œ ìí­í•˜ì—¬ ì½”ì–´ HP -1.</li>
            <li><b>Overseer</b> â€” 1ì¹¸ ì „ë°©í–¥. ê°™ì€ í–‰/ì—´ì˜ ì•„êµ°ì€ ì´ë™ê±°ë¦¬ +1(ë²„í”„).</li>
            <li><b>Core</b> â€” 2Ã—2, HP 3. HP 0ì´ë©´ íŒ¨ë°°.</li>
          </ul>
        </div>

        <div class="log" id="log"></div>
      </div>
    </div>
  </div>

<script>
/* ========== êµ¬ì¡°í™”ëœ êµ¬í˜„ (ë‹¤ì„¯ ë²ˆì˜ ë””ë²„ê¹…ì„ ê±°ì³ ì •ë¦¬ë¨) ========== */

/* ê¸°ë³¸ ìƒìˆ˜ ë° DOM ì°¸ì¡° */
const ROWS = 10, COLS = 10;
const boardEl = document.getElementById('board');
const logEl = document.getElementById('log');
const selLabel = document.getElementById('selLabel');
const turnLabel = document.getElementById('turnLabel');
const hpP0 = document.getElementById('hpP0'), hpP1 = document.getElementById('hpP1');
const btnEnd = document.getElementById('btnEnd'), btnReset = document.getElementById('btnReset');
const turnCountEl = document.getElementById('turnCount');

let currentPlayer = 0; // 0 = P1, 1 = P2
let turnCount = 0;
let selected = null; // {r,c}
let gridMap = new Map(); // key "r,c" -> cell object
let gameOver = false;
let coreHP = [3,3];

/* ê¸°ë¬¼ íƒ€ì…(ì‹ë³„ì ë° ì„¤ëª…ìš©) */
const TYPES = {
  core: {id:'core', name:'Core', immobile:true},
  sentinel: {id:'sentinel', name:'Sentinel'},
  phantom: {id:'phantom', name:'Phantom'},
  arbiter: {id:'arbiter', name:'Arbiter'},
  crusader: {id:'crusader', name:'Crusader'},
  drone: {id:'drone', name:'Drone'},
  overseer: {id:'overseer', name:'Overseer'}
};

/* ìœ í‹¸ë¦¬í‹° */
const key = (r,c) => `${r},${c}`;
const colLetter = i => String.fromCharCode(97 + i);
const inBoard = (r,c) => r>=1 && r<=ROWS && c>=1 && c<=COLS;
const getCell = (r,c) => gridMap.get(key(r,c));
const playerName = p => p===0 ? 'í”Œë ˆì´ì–´1(ê²€ì •)' : 'í”Œë ˆì´ì–´2(í°)';
function log(msg){ logEl.innerHTML += `${msg}<br>`; logEl.scrollTop = logEl.scrollHeight; }

/* ì´ˆê¸° ê·¸ë¦¬ë“œ ìƒì„±: cell = {r,c,el,occupant:null,coreOwner:null,meta:{}} */
function initGrid(){
  boardEl.innerHTML = '';
  gridMap.clear();
  for(let r=1;r<=ROWS;r++){
    for(let c=1;c<=COLS;c++){
      const el = document.createElement('div');
      const parity = ((r+c) % 2 === 0) ? 'light' : 'dark';
      el.className = `cell ${parity}`;
      el.dataset.r = r;
      el.dataset.c = c;
      const coord = document.createElement('div');
      coord.className = 'coord';
      coord.textContent = `${colLetter(c-1)}${r}`;
      el.appendChild(coord);
      el.addEventListener('click', ()=> onCellClick(r,c));
      boardEl.appendChild(el);
      gridMap.set(key(r,c), {r,c,el,occupant:null, coreOwner:null, meta:{}});
    }
  }
}

/* ì½”ì–´ ì¢Œí‘œ(ìš”ì²­ ë°˜ì˜): P1 (2,b)-(3,c) -> (2,2),(2,3),(3,2),(3,3) ; P2 (8,h)-(9,i) -> (8,8),(8,9),(9,8),(9,9) */
const P1_CORE = [[2,2],[2,3],[3,2],[3,3]];
const P2_CORE = [[8,8],[8,9],[9,8],[9,9]];

/* ë³´ë“œ ì´ˆê¸° ê¸°ë¬¼ ë°°ì¹˜(êµ¬ì„ ì¤‘ì‹¬ ë°°ì¹˜) - ì¶©ëŒ í”¼í•´ì„œ ë°°ì¹˜ ë¦¬ìŠ¤íŠ¸ ì‚¬ìš© */
function placeInitialPieces(){
  // clear
  for(const cell of gridMap.values()){ cell.occupant = null; cell.coreOwner = null; cell.meta = {}; }

  // set core owners (core cells not occupied by movable pieces)
  P1_CORE.forEach(([r,c]) => { const cell = getCell(r,c); if(cell) cell.coreOwner = 0; });
  P2_CORE.forEach(([r,c]) => { const cell = getCell(r,c); if(cell) cell.coreOwner = 1; });

  // P1 positions (near top-left corner region)
  const p1 = {
    sentinel: [[1,1],[1,4],[4,1],[4,4]],
    phantom: [[1,2],[1,3]],
    arbiter: [[1,5],[1,6]],
    crusader: [[2,1],[3,1]],
    overseer: [[1,10]],
    droneRow: 4 // fill row 4 for drones except core
  };
  // Place P1 special pieces
  for(const [type, arr] of Object.entries({sentinel:p1.sentinel, phantom:p1.phantom, arbiter:p1.arbiter, crusader:p1.crusader})){
    arr.forEach(([r,c]) => setPiece(r,c,0,type));
  }
  setPiece(1,10,0,'overseer');
  // P1 drones across row 4 (skip core cells)
  for(let c=1;c<=COLS;c++){
    const r = p1.droneRow;
    const cell = getCell(r,c);
    if(cell && !cell.coreOwner && !cell.occupant) setPiece(r,c,0,'drone');
  }

  // P2 positions (mirror bottom-right)
  const p2 = {
    sentinel: [[10,10],[10,7],[7,10],[7,7]],
    phantom: [[10,9],[10,8]],
    arbiter: [[10,6],[10,5]],
    crusader: [[9,10],[8,10]],
    overseer: [[10,1]],
    droneRow: 7
  };
  for(const [type, arr] of Object.entries({sentinel:p2.sentinel, phantom:p2.phantom, arbiter:p2.arbiter, crusader:p2.crusader})){
    arr.forEach(([r,c]) => setPiece(r,c,1,type));
  }
  setPiece(10,1,1,'overseer');
  for(let c=1;c<=COLS;c++){
    const r = p2.droneRow;
    const cell = getCell(r,c);
    if(cell && !cell.coreOwner && !cell.occupant) setPiece(r,c,1,'drone');
  }

  // reset core HP
  coreHP = [3,3];
  updateHP();
}

/* set piece helper */
function setPiece(r,c,player,type){
  const cell = getCell(r,c);
  if(!cell) return;
  cell.occupant = {player, type, meta:{}};
}

/* rendering */
function render(){
  for(const cell of gridMap.values()){
    const el = cell.el;
    // reset classes
    el.classList.remove('core1','core2','core-border','highlight-move','highlight-attack');
    // apply core backgrounds
    if(cell.coreOwner === 0) el.classList.add('core1');
    else if(cell.coreOwner === 1) el.classList.add('core2');
    // core border accent
    if(cell.coreOwner !== null) el.classList.add('core-border');
    // clean piece/type nodes
    Array.from(el.querySelectorAll('.piece, .type-label, .stasis-overlay')).forEach(n => n.remove());
    // show occupant if exists
    if(cell.occupant){
      const p = cell.occupant;
      const node = document.createElement('div');
      node.className = 'piece ' + (p.player===0 ? 'p0' : 'p1');
      node.textContent = p.type[0].toUpperCase();
      el.appendChild(node);
      const lbl = document.createElement('div'); lbl.className='type-label'; lbl.textContent = p.type.slice(0,3).toUpperCase();
      el.appendChild(lbl);
      // show cooldown marker if phantom in cooldown
      if(p.meta && p.meta.cooldownTurns > 0){
        const cd = document.createElement('div');
        cd.style.position='absolute'; cd.style.left='6px'; cd.style.bottom='6px'; cd.style.fontSize='10px'; cd.style.color='#b00';
        cd.textContent = `CD${p.meta.cooldownTurns}`;
        el.appendChild(cd);
      }
    }
    // show stasis overlay if cell.meta.stasisTurns > 0
    if(cell.meta && cell.meta.stasisTurns && cell.meta.stasisTurns > 0){
      const ov = document.createElement('div');
      ov.className = 'stasis-overlay';
      ov.textContent = 'LOCK';
      el.appendChild(ov);
    }
  }
  updateSidebar();
}

/* sidebar update */
function updateSidebar(){
  selLabel.textContent = selected ? `${colLetter(selected.c-1)}${selected.r}` : 'ì—†ìŒ';
  turnLabel.textContent = `í„´: ${playerName(currentPlayer)}`;
  turnCountEl.textContent = turnCount;
  hpP0.textContent = coreHP[0]; hpP1.textContent = coreHP[1];
}

/* handle cell clicks */
function onCellClick(r,c){
  if(gameOver) return;
  const cell = getCell(r,c);
  // if not selected: select own movable piece
  if(!selected){
    if(!cell.occupant){ log('ê¸°ë¬¼ì„ ì„ íƒí•˜ì„¸ìš”.'); return; }
    if(cell.occupant.player !== currentPlayer){ log('ìì‹ ì˜ ê¸°ë¬¼ë§Œ ì„ íƒ ê°€ëŠ¥í•©ë‹ˆë‹¤.'); return; }
    if(cell.occupant.type === 'core'){ log('ì½”ì–´ëŠ” ì„ íƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
    // if stasis on cell, cannot select/move
    if(cell.meta && cell.meta.stasisTurns > 0){ log('ì´ ê¸°ë¬¼ì€ ì†ë°•ë˜ì–´ ì´ë™í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
    selected = {r,c};
    clearHighlights();
    highlightMoves(selected.r, selected.c);
    render();
    return;
  }
  // if clicked same cell -> deselect
  if(selected.r === r && selected.c === c){ selected = null; clearHighlights(); render(); return; }

  const tgt = getCell(r,c);
  if(tgt.el.classList.contains('highlight-move')){
    performMove(selected, {r,c});
    selected = null; clearHighlights(); render();
    return;
  }
  if(tgt.el.classList.contains('highlight-attack')){
    performAttack(selected, {r,c});
    selected = null; clearHighlights(); render();
    return;
  }
  log('ìœ íš¨í•œ ëŒ€ìƒ(ì´ë™/ê³µê²©)ì„ ì„ íƒí•˜ì„¸ìš”.');
}

/* clear highlights */
function clearHighlights(){ for(const cell of gridMap.values()){ cell.el.classList.remove('highlight-move','highlight-attack'); } }

/* check overseer buff for a player's piece at (r,c): returns buffRange (integer) */
function overseerBuffFor(player, r, c){
  // if any overseer of same player exists in same row or same column -> buff +1
  for(const cell of gridMap.values()){
    if(cell.occupant && cell.occupant.player === player && cell.occupant.type === 'overseer'){
      if(cell.r === r || cell.c === c) return 1;
    }
  }
  return 0;
}

/* highlight logic per piece (uses getCell and gridMap) */
function highlightMoves(r,c){
  const src = getCell(r,c);
  if(!src || !src.occupant) return;
  const occ = src.occupant;
  const player = occ.player;
  const type = occ.type;
  const buff = overseerBuffFor(player, r, c); // buff increments range where applicable

  const markMove = (cell) => { if(cell && !cell.coreOwner && !cell.occupant) cell.el.classList.add('highlight-move'); };
  const markAttack = (cell) => { if(cell) cell.el.classList.add('highlight-attack'); };

  // if phantom in cooldown, restrict moves to orth 1 only
  const phantomCooldown = (type === 'phantom' && occ.meta && occ.meta.cooldownTurns > 0);

  if(type === 'sentinel'){
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dr,dc] of dirs){
      let step = 1;
      while(true){
        const nr = r + dr*step, nc = c + dc*step;
        if(!inBoard(nr,nc)) break;
        const t = getCell(nr,nc);
        if(t.occupant === null){
          // allow drone to move into core? sentinel moving into core shouldn't occupy, treat core as attack target instead
          if(t.coreOwner === null) markMove(t);
          else { /* core present: treat as attack */ if(t.coreOwner !== player) markAttack(t); break; }
        } else {
          if(t.occupant.player !== player){
            // enemy encountered: if behind is empty -> push attack OR if target is core -> core attack
            const br = nr + dr, bc = nc + dc;
            if(inBoard(br,bc) && !getCell(br,bc).occupant && getCell(br,bc).coreOwner === null){
              markAttack(t);
            } else if(t.coreOwner !== null && t.coreOwner !== player){
              markAttack(t);
            }
          }
          break;
        }
        step++;
      }
    }
  } else if(type === 'phantom'){
    // if on cooldown: only orth 1 allowed
    if(phantomCooldown){
      const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
      dirs.forEach(([dr,dc]) => {
        const nr=r+dr, nc=c+dc;
        if(!inBoard(nr,nc)) return;
        const t = getCell(nr,nc);
        if(!t.occupant && t.coreOwner===null) markMove(t);
        else if(t.occupant && t.occupant.player !== player) markAttack(t);
        else if(t.coreOwner !== null && t.coreOwner !== player) markAttack(t);
      });
    } else {
      const moves = [[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
      moves.forEach(([dr,dc])=>{
        const nr=r+dr, nc=c+dc;
        if(!inBoard(nr,nc)) return;
        const t = getCell(nr,nc);
        if(!t.occupant && t.coreOwner===null) markMove(t);
        else if(t.occupant && t.occupant.player !== player) markAttack(t);
        else if(t.coreOwner !== null && t.coreOwner !== player) markAttack(t);
      });
    }
  } else if(type === 'arbiter'){
    const dirs = [[1,1],[1,-1],[-1,1],[-1,-1]];
    for(const [dr,dc] of dirs){
      let step=1;
      while(true){
        const nr=r+dr*step, nc=c+dc*step;
        if(!inBoard(nr,nc)) break;
        const t = getCell(nr,nc);
        if(!t.occupant){
          if(t.coreOwner === null) markMove(t);
          else { if(t.coreOwner !== player) markAttack(t); break; }
        } else {
          if(t.occupant.player !== player) markAttack(t);
          break;
        }
        step++;
      }
    }
  } else if(type === 'crusader'){
    // orth up to 2 (+buff)
    const maxOrth = 2 + buff;
    const orth = [[1,0],[-1,0],[0,1],[0,-1]];
    for(const [dr,dc] of orth){
      for(let step=1; step<=maxOrth; step++){
        const nr=r+dr*step, nc=c+dc*step;
        if(!inBoard(nr,nc)) break;
        const t = getCell(nr,nc);
        if(!t.occupant){
          if(t.coreOwner===null) markMove(t);
          else { if(t.coreOwner !== player) markAttack(t); break; }
        } else {
          if(t.occupant.player !== player){
            const br = nr + dr, bc = nc + dc;
            if(inBoard(br,bc) && !getCell(br,bc).occupant && getCell(br,bc).coreOwner===null) markAttack(t);
            else if(t.coreOwner !== null && t.coreOwner !== player) markAttack(t);
          }
          break;
        }
      }
    }
    // diag 1
    const diags = [[1,1],[1,-1],[-1,1],[-1,-1]];
    diags.forEach(([dr,dc])=>{
      const nr=r+dr, nc=c+dc;
      if(!inBoard(nr,nc)) return;
      const t = getCell(nr,nc);
      if(!t.occupant && t.coreOwner===null) markMove(t);
      else if(t.occupant && t.occupant.player !== player) markAttack(t);
      else if(t.coreOwner !== null && t.coreOwner !== player) markAttack(t);
    });
  } else if(type === 'drone'){
    const dir = player===0 ? 1 : -1;
    const nr = r + dir, nc = c;
    if(inBoard(nr,nc)){
      const t = getCell(nr,nc);
      // allow drone to move into core (self-destruct) -> treat as move
      if(!t.occupant) markMove(t);
      else if(t.occupant.player !== player) markAttack(t);
    }
    // starting double move (we placed drones at specific rows)
    const startRow = player===0 ? 4 : 7;
    if(r === startRow){
      const nr2 = r + dir*2;
      if(inBoard(nr2,nc) && !getCell(r+dir,nc).occupant && !getCell(nr2,nc).occupant) markMove(getCell(nr2,nc));
    }
  } else if(type === 'overseer'){
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        if(dr===0 && dc===0) continue;
        const nr=r+dr, nc=c+dc;
        if(!inBoard(nr,nc)) continue;
        const t = getCell(nr,nc);
        if(!t.occupant && t.coreOwner===null) markMove(t);
        else if(t.occupant && t.occupant.player !== player) markAttack(t);
        else if(t.coreOwner !== null && t.coreOwner !== player) markAttack(t);
      }
    }
  }
}

/* move (non-attack) logic: respects core as special cell (don't place occupant on core) */
function performMove(from, to){
  const src = getCell(from.r, from.c), dst = getCell(to.r, to.c);
  if(!src || !dst || !src.occupant) return;
  const occ = src.occupant;
  // if destination is core owned by opponent -> handle damage
  if(dst.coreOwner !== null && dst.coreOwner !== occ.player){
    // drone self-destruct specially
    if(occ.type === 'drone'){
      coreHP[dst.coreOwner] -= 1;
      src.occupant = null; // drone removed
      log(`${playerName(occ.player)}ì˜ Droneì´ ${coord(to)}ì— ëŒì…í•˜ì—¬ ìí­: ì½”ì–´ HP -1 (ë‚¨ìŒ ${coreHP[dst.coreOwner]})`);
      updateHP(); checkGameOver();
      endTurnHousekeeping();
      return;
    } else {
      // non-drone pieces damage core by 1 but DO NOT occupy core cell
      coreHP[dst.coreOwner] -= 1;
      log(`${playerName(occ.player)}ì˜ ${occ.type}ì´(ê°€) ìƒëŒ€ ì½”ì–´ì— ì§„ì… ì‹œë„: ì½”ì–´ HP -1 (ë‚¨ìŒ ${coreHP[dst.coreOwner]})`);
      updateHP(); checkGameOver();
      // move piece to dst? We choose to keep piece in src (no occupation) to avoid overwriting core cell
      // but to keep previous behavior similar, move piece adjacent (not on core). We'll NOT move onto core.
      endTurnHousekeeping();
      return;
    }
  }
  // normal move into empty non-core cell
  dst.occupant = occ;
  src.occupant = null;
  log(`${playerName(occ.player)} ì´ë™: ${coord(from)} â†’ ${coord(to)}`);
  endTurnHousekeeping();
}

/* attack logic: handles each type's special attack effects */
function performAttack(from, to){
  const src = getCell(from.r, from.c), dst = getCell(to.r, to.c);
  if(!src || !dst || !src.occupant) return;
  const occ = src.occupant;
  const player = occ.player;
  const type = occ.type;

  if(type === 'sentinel'){
    // push attack: push enemy to behind
    const dr = dst.r - src.r, dc = dst.c - src.c;
    const br = dst.r + dr, bc = dst.c + dc;
    if(inBoard(br,bc) && !getCell(br,bc).occupant && getCell(br,bc).coreOwner===null){
      getCell(br,bc).occupant = dst.occupant;
      dst.occupant = occ;
      src.occupant = null;
      log(`${playerName(player)}ì˜ Sentinelì´ ${coord(to)} ê³µê²©: ì ì„ ${coord({r:br,c:bc})}ë¡œ ë°€ì–´ëƒ„`);
    } else {
      // if dst is coreOwner (core cell), allow damage instead
      if(dst.coreOwner !== null && dst.coreOwner !== player){
        coreHP[dst.coreOwner] -= 1;
        log(`${playerName(player)}ì˜ Sentinelì´ ìƒëŒ€ ì½”ì–´ì— ê³µê²©í•˜ì—¬ HP -1 (ë‚¨ìŒ ${coreHP[dst.coreOwner]})`);
        updateHP(); checkGameOver();
      } else { log('ë°€ê¸° ë¶ˆê°€: ë’¤ì¹¸ì´ ë¹„ì–´ìˆì§€ ì•ŠìŒ.'); return; }
    }
  } else if(type === 'phantom'){
    // jump capture: midpoint removed if enemy
    const midr = (from.r + to.r) / 2, midc = (from.c + to.c) / 2;
    if(Number.isInteger(midr) && Number.isInteger(midc)){
      const mid = getCell(midr, midc);
      if(mid && mid.occupant && mid.occupant.player !== player){
        mid.occupant = null;
      }
    }
    // landing on core damages core (but won't occupy core)
    if(dst.coreOwner !== null && dst.coreOwner !== player){
      coreHP[dst.coreOwner] -= 1;
      log(`${playerName(player)}ì˜ Phantomì´ ì½”ì–´ ê·¼ì²˜ ì í”„: ì½”ì–´ HP -1 (ë‚¨ìŒ ${coreHP[dst.coreOwner]})`);
      updateHP(); checkGameOver();
      // phantom lands but if landing cell is core, we do not place occupant on core
      if(dst.coreOwner === null) dst.occupant = occ;
      else src.occupant = null; // remove original phantom to imply jump used
    } else {
      dst.occupant = occ;
      src.occupant = null;
    }
    // apply phantom cooldown: next turn restricted
    dst.occupant && (dst.occupant.meta.cooldownTurns = 1);
    log(`${playerName(player)}ì˜ Phantomì´ ì í”„: ${coord(from)} â†’ ${coord(to)} (ì¿¨ë‹¤ìš´ ë¶€ì—¬)`);
  } else if(type === 'arbiter'){
    // capture & stasis: remove enemy and apply stasis on that cell for 1 turn, then occupy cell
    if(dst.occupant && dst.occupant.player !== player){
      dst.occupant = {player,type:'arbiter',meta:{}}; // arbiter moves in
      src.occupant = null;
      dst.meta = dst.meta || {};
      dst.meta.stasisTurns = 1; // blocks movement from this cell for next turn
      log(`${playerName(player)}ì˜ Arbiterê°€ ${coord(to)}ì˜ ì ì„ ì†ë°•(ì œê±°)í•˜ê³  ìë¦¬ ì°¨ì§€`);
    } else if(dst.coreOwner !== null && dst.coreOwner !== player){
      // attacking core: damage
      coreHP[dst.coreOwner] -= 1;
      log(`${playerName(player)}ì˜ Arbiterê°€ ìƒëŒ€ ì½”ì–´ ê³µê²©: HP -1 (ë‚¨ìŒ ${coreHP[dst.coreOwner]})`);
      updateHP(); checkGameOver();
    } else {
      log('Arbiter ê³µê²© ì‹¤íŒ¨');
      return;
    }
  } else if(type === 'crusader'){
    // diag capture: simple replace; orth push if behind empty
    const dr = dst.r - src.r, dc = dst.c - src.c;
    if(Math.abs(dr) === Math.abs(dc) && Math.abs(dr) === 1){
      dst.occupant = occ;
      src.occupant = null;
      log(`${playerName(player)}ì˜ Crusaderê°€ ëŒ€ê°ì„ ìœ¼ë¡œ ${coord(to)} ì ë ¹`);
    } else {
      const br = dst.r + Math.sign(dr), bc = dst.c + Math.sign(dc);
      if(inBoard(br,bc) && !getCell(br,bc).occupant && getCell(br,bc).coreOwner===null){
        getCell(br,bc).occupant = dst.occupant;
        dst.occupant = occ;
        src.occupant = null;
        log(`${playerName(player)}ì˜ Crusaderê°€ ${coord(to)} ê³µê²©: ì ì„ ${coord({r:br,c:bc})}ë¡œ ë°€ì–´ëƒ„`);
      } else if(dst.coreOwner !== null && dst.coreOwner !== player){
        coreHP[dst.coreOwner] -= 1;
        log(`${playerName(player)}ì˜ Crusaderê°€ ìƒëŒ€ ì½”ì–´ì— ê³µê²©: HP -1 (ë‚¨ìŒ ${coreHP[dst.coreOwner]})`);
        updateHP(); checkGameOver();
      } else {
        log('Crusader ë°€ê¸° ì‹¤íŒ¨: ë’¤ì¹¸ì´ ë¹„ì–´ìˆì§€ ì•ŠìŒ.');
        return;
      }
    }
  } else if(type === 'drone'){
    // drone attack: replace target (forward capture). If target is core, drone self-destruct and damage core.
    if(dst.coreOwner !== null && dst.coreOwner !== player){
      coreHP[dst.coreOwner] -= 1;
      src.occupant = null;
      log(`${playerName(player)}ì˜ Droneì´ ì½”ì–´ ìí­ ê³µê²©: ì½”ì–´ HP -1 (ë‚¨ìŒ ${coreHP[dst.coreOwner]})`);
      updateHP(); checkGameOver();
    } else {
      dst.occupant = occ;
      src.occupant = null;
      log(`${playerName(player)}ì˜ Droneì´ ${coord(to)}ë¡œ ëŒíŒŒí•˜ì—¬ ì ë ¹`);
    }
  } else if(type === 'overseer'){
    // capture
    dst.occupant = occ;
    src.occupant = null;
    log(`${playerName(player)}ì˜ Overseerê°€ ${coord(to)}ì˜ ì ì„ ì œê±°`);
  }

  endTurnHousekeeping();
}

/* turn housekeeping: decrement metas, check drone-core auto, apply end-turn */
function endTurnHousekeeping(){
  // decrement stasis and cooldowns
  for(const cell of gridMap.values()){
    if(cell.meta && cell.meta.stasisTurns){
      cell.meta.stasisTurns -= 1;
      if(cell.meta.stasisTurns <= 0) delete cell.meta.stasisTurns;
    }
    if(cell.occupant && cell.occupant.meta){
      if(typeof cell.occupant.meta.cooldownTurns === 'number'){
        cell.occupant.meta.cooldownTurns -= 1;
        if(cell.occupant.meta.cooldownTurns <= 0) delete cell.occupant.meta.cooldownTurns;
      }
    }
  }
  // drones already handled in attack/move. But check drones that may have moved into core by other logic:
  for(const cell of gridMap.values()){
    if(cell.occupant && cell.occupant.type === 'drone'){
      const core = cell.coreOwner;
      if(core !== null && core !== cell.occupant.player){
        // drone self-destruct
        coreHP[core] -= 1;
        log(`${playerName(cell.occupant.player)}ì˜ Droneì´ ${coord({r:cell.r,c:cell.c})}ì—ì„œ ìí­: ì½”ì–´ HP -1 (ë‚¨ìŒ ${coreHP[core]})`);
        cell.occupant = null;
        updateHP(); checkGameOver();
      }
    }
  }

  // advance turn
  currentPlayer = 1 - currentPlayer;
  turnCount++;
  render();
}

/* helpers */
function coord(pos){ return `${colLetter(pos.c-1)}${pos.r}`; }
function updateHP(){ hpP0.textContent = coreHP[0]; hpP1.textContent = coreHP[1]; }
function checkGameOver(){
  if(coreHP[0] <= 0 || coreHP[1] <= 0){
    const winner = coreHP[0] <= 0 ? 1 : 0;
    log(`ğŸ‰ ${playerName(winner)} ìŠ¹ë¦¬! ìƒëŒ€ ì½”ì–´ íŒŒê´´.`);
    gameOver = true;
    for(const cell of gridMap.values()) cell.el.style.pointerEvents = 'none';
  }
}

/* end-turn and reset bindings */
btnEnd.addEventListener('click', ()=>{ if(gameOver) return; selected = null; clearHighlights(); currentPlayer = 1 - currentPlayer; turnCount++; render(); });
btnReset.addEventListener('click', resetGame);
window.addEventListener('keydown', (e) => { if(e.key === 'r' || e.key === 'R') resetGame(); });

/* reset */
function resetGame(){
  gameOver = false; selected = null; currentPlayer = 0; turnCount = 0;
  initGrid(); placeInitialPieces(); render();
  for(const cell of gridMap.values()) cell.el.style.pointerEvents = 'auto';
  log('ê²Œì„ ë¦¬ì…‹');
}

/* startup */
initGrid();
placeInitialPieces();
render();
log('ê²Œì„ ì‹œì‘: í”Œë ˆì´ì–´1(ê²€ì •) ì°¨ë¡€');

/* expose for debugging */
window._gridMap = gridMap;
window.resetGame = resetGame;

</script>
</body>
</html>
